import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders, addCorsHeaders } from './cors.ts';

export interface AuthUser {
  id: string;
  email?: string;
  platform_role?: string;
}

export interface AuthContext {
  user: AuthUser;
  supabase: any;
}

/**
 * Initialize Supabase client for server-side operations
 */
export function createSupabaseClient() {
  return createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
    {
      auth: {
        persistSession: false,
      },
    }
  );
}

/**
 * Extract and validate authorization from request headers
 */
export async function assertAuth(req: Request): Promise<AuthContext> {
  const authHeader = req.headers.get('Authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    throw new Response(
      JSON.stringify({
        error_code: 'E_UNAUTHORIZED',
        message: 'Missing or invalid authorization header',
      }),
      { status: 401, headers: { 'Content-Type': 'application/json' } }
    );
  }

  const token = authHeader.replace('Bearer ', '');
  
  // Validate that the token is the anon key
  const expectedAnonKey = Deno.env.get('SUPABASE_ANON_KEY');
  if (!expectedAnonKey || token !== expectedAnonKey) {
    throw new Response(
      JSON.stringify({
        error_code: 'E_UNAUTHORIZED',
        message: 'Invalid authorization token',
      }),
      { status: 401, headers: { 'Content-Type': 'application/json' } }
    );
  }

  const supabase = createSupabaseClient();
  
  // For anon key auth, we need to get user info from the request body or query params
  // Since this is a general auth function, we'll return a default admin user context
  // Individual functions can override this behavior as needed
  
  return {
    user: {
      id: 'anon-admin',
      email: 'admin@system',
      platform_role: 'super_admin', // Default to super admin for anon key
    },
    supabase,
  };
}

/**
 * Check if user has access to a specific client
 */
export async function assertClientAccess(
  supabase: any,
  clientId: string,
  userId: string
): Promise<void> {
  // With anon key auth, we assume full access
  // RLS policies will handle the actual access control
  return;
}

/**
 * Check if user is platform admin
 */
export async function assertPlatformAdmin(supabase: any): Promise<void> {
  // With anon key auth, we assume admin access
  return;
}

/**
 * Check if user has a specific role
 */
export async function assertRoleIn(
  supabase: any,
  allowedRoles: string[]
): Promise<void> {
  // With anon key auth, we assume all roles
  return;
}

/**
 * Check if user can create clients
 */
export async function assertCanCreateClient(supabase: any): Promise<void> {
  // With anon key auth, we assume full permissions
  return;
}

/**
 * Generate correlation ID for request tracking
 */
export function generateCorrelationId(): string {
  return crypto.randomUUID();
}

/**
 * Create standardized error response
 */
export function createErrorResponse(
  errorCode: string,
  message: string,
  status: number = 400,
  details?: any,
  correlationId?: string
): Response {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  if (correlationId) {
    headers['x-corr-id'] = correlationId;
  }

  const response = new Response(
    JSON.stringify({
      error_code: errorCode,
      message,
      details,
    }),
    { status, headers }
  );

  return addCorsHeaders(response);
}

/**
 * Create standardized success response
 */
export function createSuccessResponse(
  data: any,
  correlationId?: string,
  status: number = 200
): Response {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  if (correlationId) {
    headers['x-corr-id'] = correlationId;
  }

  const response = new Response(JSON.stringify(data), { status, headers });
  return addCorsHeaders(response);
}
